[基础知识笔记](https://zhuzhuzhus.github.io/2024/09/01/aarch64/)
## arm64指令
### 加载与存储指令
#### LDR STR 指令
前变基的LDR指令编码如下所示：
- 0-4位用来描述目标寄存器
- 5-8位用来描述源寄存器
- 12-20位用来描述源寄存器的偏移量
- 21-29位用于指令分类
- 30-31位为size字段，为0b11时表示64位，为0b10时表示32位

#### 基于基地址的寻址模式
1. 基地址寻址
    ~~~asm
    LDR Xt,[Xn] //以Xn寄存器中的内容作为内存地址，加载此地址的内容到Xt寄存器中
    STR Xt,[Xn] //以Xn寄存器中的内容作为内存地址，将Xt寄存器中的内容存储到此地址中
    ~~~
2. 基地址偏移寻址
    ~~~asm
    LDR Xt,[Xn,#imm] //以Xn寄存器中的内容加上imm偏移量作为内存地址，加载此地址的内容到Xt寄存器中
    STR Xt,[Xn,#imm] //以Xn寄存器中的内容加上imm偏移量作为内存地址，将Xt寄存器中的内容存储到此地址中
    ~~~
    - Xt: 目标寄存器
    - Xn: 基地址寄存器
    - imm: 立即数，表示地址偏移量，偏移量大小为imm12(指令10-21位)的8倍范围为0-32760B，所以这个立即数必须为8的倍数
3. 基地址扩展模式
    ~~~asm
    LDR <Xt>,[Xn,(Xm)]{,<extend> {<amount>}}
    STR <Xt>,[Xn,(Xm)]{,<extend> {<amount>}}
    ~~~
    参数如下：
    - Xt: 目标寄存器
    - Xn: 基地址寄存器
    - Xm: 用来表示偏移的寄存器
    - extend: 表示扩展模式，默认为LSL，对应编码中的option字段(13-15位)：
        - 为010时，extend编码为UXTW，表示从寄存器中提取32位数据，高位填充0
        - 为011时，extend编码为LSL,表示逻辑左移
        - 为110时，extend编码为SXTW，表示从寄存器中提取32位数据，高位填充符号位
        - 为111时，extend编码为SXTX，表示从寄存器中提取64位数据。
    - amount: 索引偏移量，当extend参数为LSL时，可以省略，否则需要指定。
详见p40

#### 变基模式
1. 前变基模式
    ~~~asm
    LDR <Xt>,[<Xn>,#imm]!
    STR <Xt>,[<Xn>,#imm]!
    ~~~
    首先更新Xn寄存器的值，然后将Xn寄存器中的内容加上imm偏移量作为内存地址，加载此地址的内容到Xt寄存器中，或者将Xt寄存器中的内容存储到此地址中。
2. 后变基模式
    ~~~asm
    LDR <Xt>,[<Xn>],#imm
    STR <Xt>,[<Xn>],#imm
    ~~~
    首先将Xn寄存器中的内容作为内存地址，加载此地址的内容到Xt寄存器中，或者将Xt寄存器中的内容存储到此地址中，然后更新Xn寄存器的值。

#### PC相对寻址

~~~asm
LDR <Xt>,<label>
~~~
这条指令将label所在内存地址的内容读到Xt寄存器中，但是这个label必须在当前PC地址前后1MB范围内。

~~~asm
mydata:
    .word 0x12345678
ldr x0, mydata
~~~
ldr指令将mydata所在内存地址的内容读到x0寄存器中，最终x0=0x12345678。

~~~asm
#define OFFSET 0x20
ldr x0, OFFSET
~~~
ldr会读取pc+offset地址的内容到x0寄存器中。

#### LDR伪指令
伪指令是对汇编器发出的命令，在源程序汇编期间由汇编器进行处理，一条伪指令可以分解为几条指令的集合
~~~asm
ldr x0, =0x12345678
~~~
这条指令将0x12345678读到x0寄存器中。

~~~asm
mydata:
   .quad 0x8

ldr x0, =mydata
ldr x2,[x0]
~~~
mydata是一个64位的地址，ldr x0,=mydata将mydata的地址读到x0寄存器中，ldr x2,[x0]将x0寄存器中的内容作为地址，读取此地址的内容到x2寄存器中，最终x2=0x8。

#### 多字节内存加载和存储指令LDP STP
LDP和STP指令用于加载和存储多个寄存器的值，它们的编码格式如下：
LDP指令：
~~~asm
LDP <Xt1>,<Xt2>,[<Xn>{,#<imm>}]
~~~
他以Xn寄存器中的内容作为内存地址，读取此地址＋imm地址的值到Xt1寄存器，读取此地址＋imm＋8地址的值到Xt2寄存器。
STP指令：
~~~asm
STP <Xt1>,<Xt2>,[<Xn>{,#<imm>}]
~~~
他以Xn寄存器中的内容作为内存地址，将Xt1寄存器中的内容存储到此地址＋imm地址中，将Xt2寄存器中的内容存储到此地址＋imm＋8地址中。

前变基与后变基与ldr指令类似。

**偏移量必须在-512-504并且必须为8的倍数**

#### mov指令
这里不过多介绍mov指令，只针对介绍mov指令使用的一些要点
1. mov指令能搬运的立即数只有两种
    - 16位的立即数
    - 16位立即数左移16位，32位或者48位后的立即数
2. 能搬运一些用于位图的立即数，此时等于orr指令

#### 陷阱

~~~asm
#define MY_LABEL 0X30
ldr x0, =MY_LABEL #伪指令，x0 = 0x30
ldr x0, MY_LABEL  #x0为PC+0x30地址中的值

mydata:
~~~

### 算术与移位指令
首先了解操作符后缀
| 条件码 | 后缀助记符 |    标志位     |                             定义                             |
| :----: | :--------: | :-----------: | :----------------------------------------------------------: |
|  0000  |     EQ     |      Z=1      |                             相等                             |
|  0001  |     NE     |      Z=0      |                            不相等                            |
|  0010  |   CS/HS    |      C=1      |                      无符号大于或者等于                      |
|  0011  |   CC/LO    |      C=0      |                          无符号小于                          |
|  0100  |     MI     |      N=1      |                             负值                             |
|  0101  |     PL     |      N=0      |                           正值或0                            |
|  0110  |     VS     |      V=1      |                             溢出                             |
|  0111  |     VC     |      V=0      |                            无溢出                            |
|  1000  |     HI     |   C=1且Z=0    |                          无符号大于                          |
|  1001  |     LS     |   C=0或Z=1    |                       无符号小于或等于                       |
|  1010  |     GE     |   N和V相同    |                       有符号大于或等于                       |
|  1011  |     LT     |   N和V不同    |                          有符号小于                          |
|  1100  |     GT     |  Z=0且N等于V  |                          有符号大于                          |
|  1101  |     LE     | Z=1或N不等于V |                       有符号小于或等于                       |
|  1110  |     AL     |     默认      |                            无条件                            |
|  1111  |     NV     |               | 无条件 |


#### 加法与减法指令

1. 使用立即数的加法指令
    ~~~asm
    add <Rd>,<Rn>,#<imm>{,<shift>}
    ~~~
    使用立即数的加法指令：
    正确的用法：
    ~~~asm
    add x0,x1,#1
    add x0,x1,#1 lsl 12
    ~~~
    错误的用法：
    ~~~asm
    add x0,x1,#4096
    add x0,x1,#1 lsl 1
    ~~~

    上面错误用法的原因是在使用立即数的add指令中对立即数的处理只占指令中的12位，所以最大只能表示4095，而sh字段只有一位，表示无位移或者左移12位。
2. 使用寄存器的加法指令
    ~~~asm
    add <Rd>,<Rn>,<Rm>{,<extend> {#amount}}
    ~~~
    重点关注extend和amount字段。
    extend对应指令编码的option字段，option的值和：
    - 000 表示对8位数据进行无符号扩展
    - 001 表示对16位数据进行无符号扩展
    - 010 表示对32位数据进行无符号扩展
    - 011 表示对64位数据进行无符号扩展
